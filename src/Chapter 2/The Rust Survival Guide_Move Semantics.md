# Rust生存指南:Move语义

短语move语义指的是在操作变量时，变量下面的数据会发生什么变化。在许多语言中，您根本不必担心这一点，特别是在垃圾收集语言中，它们会清除遗留在变量后面的混乱。为了简洁起见，下面的一些可能看起来过于简单，但它可能对你的学习旅程有帮助。

下面列出了在Rust中可能发生的四种不同类型的操作，并不是所有的操作都是明显的或明确的:
- **Move**
- **Copy**
- **Clone**
- **Borrow**

当你在Rust中移动一些东西时，数据从一个变量移动到另一个变量。移动是自动发生的，将变量从一个作用域传递到另一个作用域的默认方式是移动它。一个有用的技巧是记住，您可以将数据移动到一个范围中，然后只要该数据从该范围返回，就可以再次使用它。

执行以下函数调用:

<font face="微软雅黑">cart.buy_ticket(buyer, merchant, price, qty);</font>

由于这些参数中没有修饰(修饰符)(随着课程的进行，您将看到各种形式的修饰符)，我们知道所有这些值都被移动到buy_ticket范围。调用这个函数后，买方、商人、价格和数量等名称将无效，编译器会很高兴地告诉您这一点。

Rust中的副本正如其名字所暗示的那样。当数据需要从一个作用域到另一个作用域时，如果数据类型实现了Copy特征，那么它将自动按位复制到新的名称/位置。数字会自动复制，但字符串不会。在前面的例子中，如果价格和数量是数字，它们就会被复制而不是移动。在复制之后，您将有两个引用等效数据的名称，但它将不是对相同数据的共享引用。您可以为自己的结构实现Copy特征，但需要注意折衷。

Rust中的无性系的行为可以根据不同的类型而有所不同。任何实现Clone特征的东西的责任是它必须能够安全地复制它的内部数据。克隆与共享引用不是一回事，在排除编译器错误时，假设它们是一回事常常会使您出错。克隆是显式的，需要调用clone()函数。

Rust中的借用操作创造了对事物的引用。借用是一个巨大的新锈开发者错误的来源，这将在下文中讨论。您可以根据自己的喜好创建任意多的引用，但这些引用必须遵守臭名昭著的borrow checker规则。

Rust语言的一个重要的权衡是，为了换取无与伦比的安全性和编译时对潜在竞态条件、双空闲条件和大量其他导致运行时失败的常见原因的阻塞，当进行函数调用和进入和退出词法作用域时，开发人员必须明确地选择move语义。

老实说，并不是所有人都认为这种权衡是值得的。不管你是否这样做，都可能取决于你的经验、背景和个人偏好。