# 协作WebAssembly模块

如果您一直在热心地学习这门课程，并且已经真正掌握了出口和进口的概念，那么可能有一个问题困扰着您。很多人从“新到WebAssembly”过渡到“试图在WebAssembly中构建真正的东西”时都会遇到这个问题。

问题是这样的:如果一个模块可以通过指定另一个模块的名称和一个函数名来导入一个函数，并且一个模块可以通过简单地将函数包含在导出列表中来导出一个函数，那么一个模块可以导入另一个模块导出的函数吗?

首先，考虑模块本身没有内部定义的名称。当一个函数被导出时，它没有像imports那样的关联模块或名称空间前缀。

从表面上看，这个功能听起来是个绝妙的主意。松散耦合可移植的可重用功能——它可以从“依赖地狱”中解脱出来。然而，当我们进一步考虑它时，我们意识到允许这样做可能是相当危险的，特别是当一个模块被授予对WASI功能的访问权时。如果主机运行时的引擎启用了模块之间的“自动桥接”，那么就会出现一组完整的故障类型，从由于缺少或配置错误的依赖项而导致的运行时故障到特权升级攻击。

在某个时候(希望在不久的将来)，像引用类型和接口类型以及具有原子操作的共享内存等特性都将出现在规范和最流行的主机运行时中。当这种情况发生时，可能会有一个更好、更安全的策略，允许模块直接通信，而不需要主机充当代理。

在此之前，如果您希望模块能够通信，主机将必须设置导入，从而调用来自另一个模块的导出(例如，充当代理)。在某些情况下，根据语言、引擎实现和线程模型的不同，即使是这种解决方案也可能是不可能的。