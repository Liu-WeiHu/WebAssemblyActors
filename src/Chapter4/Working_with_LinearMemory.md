# 什么是线性记忆？

在整个课程中，我们已经多次提到WebAssembly是一个基于堆栈的虚拟机。指令和操作数被放置在堆栈上，当它们被执行时，指令被弹出堆栈，结果被推到堆栈上，生命周期继续。

就像在调用函数时，如果只能在堆栈上传递和接收数字，那么我们很快就会耗尽所有可做的事情一样，在WebAssembly机器中运行的代码如果不能在类似堆的内存存储设施上执行操作，就没有那么有用了。我们可能没有明确地提到它，但在课程的早期，当我们构建一字棋的例子时，游戏的棋盘状态实际上是存储在线性内存中的堆中。

线性内存，顾名思义，就是内存中包含连续字节的向量。WebAssembly规范允许模块拥有多个线性内存实例，但在本课程编写时，所有实际实现都假定内存操作隐式地操作索引为0的内存实例。

线性内存的分配是页面大小的倍数(65535字节)，WebAssembly模块可以操作该内存，而不必担心会干扰主机或其他模块使用的任何其他内存。我们之前已经看过一些WebAssembly文本格式的内存指令:
- **(type).load** - e.g. i32.load
- **(type).store** - e.g. f32.store
- **size** - 使用实例查询内存实例的大小
- **grow** - 请求内存实例的扩展。必须以页面大小的倍数指定新的最大大小。

在内部，当WebAssembly需要表示一个内存地址(例如指向堆上某个地方的指针)时，它作为一个有效地址来做，这是一个以[小端顺序](https://en.wikipedia.org/wiki/Endianness) 存储的33位值。值得庆幸的是，在使用WebAssembly或编写低级浪费代码时，我们不必担心那个级别的细节。如果只是为了更好地欣赏其他开发人员、架构师、语言设计人员和运行时构建人员为我们所做的所有工作，那么了解这些细节是有好处的。

