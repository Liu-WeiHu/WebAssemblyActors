# waPC协议(1)


函数调用流总是从主机开始。waPC是一种反应性功能协议，在这种协议中，除非客户本身被主机触发，否则客户无法发起主机调用。

waPC调用涉及两个基本的数据:一个字符串操作名，例如“HandleRequest”或“performadd”，以及包含操作参数的原始二进制有效负载。waPC不强制任何特定的序列化机制——有效负载和响应始终保持不透明的blob。

逻辑流程如下(为了简单起见，省略了一些细节):

主机通过调用“客户调用”导出来与客户发起一个函数调用交换。此导出接受两个参数:操作名称的长度(一个字符串)和二进制有效负载的长度。
1. 客户机在内部分配两个缓冲区(同样，主机不关心这是如何发生的)，然后通过“客户机请求”函数告诉主机操作名称和有效负载的两个缓冲区的线性内存地址偏移量。
2. 作为对“来宾请求”函数调用的响应，主机将调用的请求数据加载到给定指针所指示位置的线性内存中。
3. 然后，来宾模块执行其逻辑的主体
4. a.来宾模块可以选择通过“主机调用”功能向主机发出请求。主机调用函数接受许多参数，包括操作名称的指针和字节长度、有效负载(消息体)和名称空间(用于可选的操作之间的消除歧义)。
5. 客户要么通过“客户响应”功能通知主机在哪里找到响应，要么通过“客户错误”通知主机在哪里找到错误。
6. guest函数返回0表示失败，返回1表示成功。注意，默认值不能错误地解释成功。
7. 主机检查数值返回值，然后相应地检索成功字节或失败字节。更高级的项目可以使用失败字节来返回健壮的错误结构。

在下一页继续。