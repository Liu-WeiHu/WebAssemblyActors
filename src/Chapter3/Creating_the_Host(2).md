# 创建主机(2)

这段代码一开始看起来类似于我们之前的Rust主机代码。第一个看起来不同的东西是表达式let bytes ={…}。有时我们必须编写3或4行代码才能得到我们想要的单个值。在本例中，我们想要的只是字节。一旦我们得到了这些字节，我们就可以接受拉斯特丢弃文件以及我们在此期间可能创建的任何东西。这个块语法使我们这里的意图显式，并处理除了我们需要的一个返回值之外的所有东西。

这里的关键代码段是对模块变量link_closure的调用。虽然将命名导入链接到可执行代码的方法会因引擎而异，也会因语言而异，但概念是相同的:在某些时候，主机需要知道如何满足对给定导入的请求，并代表来宾WebAssembly模块调用该导入(在主机中运行的模块通常被称为来宾模块)。

这段代码将一个生成随机数的Rust闭包映射到带有random函数的模块实用程序。这是我们开始真正释放WebAssembly的一些力量的地方。由于WebAssembly模块的独立特性，导入系统非常强大。只要主机满足关于这些导入的任何隐式约定，满足该导入的代码就可以更改，而不必重新编译或重新部署客户机模块。

当我们调用cargo来执行此主机时，guest模块将向主机提供的任意随机数中添加10。你的输出会有所不同，因为我们生成的是随机数:

<font color=Blue>cargo run</font>

```text
Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/host`
Result: 89
```

这就是它所需要的!虽然不同宿主库的体验可能略有不同，但总体想法是相同的:在后端、云中或任何您可以实例化Rust二进制文件的地方托管WebAssembly模块是如此简单，几乎可以认为是令人愉快的。